<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Z1N Protocol â€“ Signals</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root{--bg:#050812;--card-bg:#020617;--text-main:#ffffff;--text-soft:#8f9ab5;--accent:#66d69a;--keys-accent:#f5c842;--keys-accent-soft:#d4a012;--card-border:rgba(148,163,184,0.25);--danger:#f97373;--stealth-color:#60a5fa}
    *{box-sizing:border-box;margin:0;padding:0}body{background:var(--bg);color:var(--text-main);font-family:system-ui,-apple-system,sans-serif;min-height:100vh}a{color:inherit;text-decoration:none}
    header{height:72px;display:flex;align-items:center;justify-content:center;border-bottom:1px solid rgba(255,255,255,0.05);margin-bottom:20px}.nav-inner{width:100%;max-width:1200px;padding:0 24px;display:flex;align-items:center;justify-content:space-between}.logo-link{display:inline-flex;align-items:center;gap:8px}.logo-dot{width:24px;height:24px;border-radius:999px;border:1px solid rgba(255,255,255,0.35);display:flex;align-items:center;justify-content:center;font-size:14px}.logo-text{font-size:11px;letter-spacing:0.18em;text-transform:uppercase;opacity:0.7}.nav-links{display:flex;gap:22px;font-size:13px;opacity:0.85}.nav-links a.active{color:var(--keys-accent)}
    .page{max-width:1200px;margin:0 auto;padding:40px 24px 80px}h1{font-size:40px;margin-bottom:8px;color:var(--keys-accent)}.subtitle{font-size:15px;color:var(--text-soft);margin-bottom:24px}
    .key-header-card{background:var(--card-bg);border:1px solid var(--card-border);border-radius:14px;padding:16px 20px;margin-bottom:20px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:16px}.key-info{display:flex;align-items:center;gap:16px}.key-id{font-size:20px;font-weight:600}.key-glyphs{font-size:16px}.key-stats{display:flex;align-items:center;gap:20px;font-size:12px;color:var(--text-soft)}.stat-group{display:flex;align-items:center;gap:8px}.stat-dots{display:flex;align-items:center;gap:4px}.dot-indicator{display:inline-block;width:12px;height:12px;border-radius:50%;border:2px solid}.dot-indicator.filled{background:#4ade80;border-color:#4ade80}.dot-indicator.open{background:transparent;border-color:var(--keys-accent)}
    .signals-layout{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:20px}@media(max-width:800px){.signals-layout{grid-template-columns:1fr}}.card{background:var(--card-bg);border:1px solid var(--card-border);border-radius:14px;padding:20px;display:flex;flex-direction:column}.card-title{font-size:13px;font-weight:600;text-transform:uppercase;letter-spacing:0.1em;color:var(--keys-accent);margin-bottom:16px}
    .toggle-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:16px}.toggle-btn{padding:8px 12px;background:rgba(15,23,42,0.4);border:1px solid rgba(245,200,66,0.35);border-radius:6px;font-size:12px;color:var(--text-main);cursor:pointer}.toggle-btn:hover{border-color:var(--keys-accent)}.toggle-btn.active{border-color:var(--keys-accent);background:rgba(245,200,66,0.2);color:var(--keys-accent)}
    .intent-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:16px}.intent-btn{display:flex;flex-direction:column;align-items:center;padding:8px 6px;background:rgba(15,23,42,0.4);border:1px solid rgba(245,200,66,0.35);border-radius:6px;cursor:pointer}.intent-btn:hover{border-color:var(--keys-accent)}.intent-btn.selected{border-color:var(--keys-accent);background:rgba(245,200,66,0.2)}.intent-symbol{font-size:13px;font-weight:700}.intent-name{font-size:9px;color:var(--text-soft);margin-top:2px}.intent-btn[data-intent="0"] .intent-symbol{color:#4ade80}.intent-btn[data-intent="1"] .intent-symbol{color:#f87171}.intent-btn[data-intent="2"] .intent-symbol{color:#fbbf24}.intent-btn[data-intent="3"] .intent-symbol{color:#60a5fa}
    .input-group{margin-bottom:12px}.input-label{font-size:11px;color:var(--text-soft);margin-bottom:4px;display:flex;justify-content:space-between}.char-count{color:var(--keys-accent)}textarea,input[type="text"],input[type="number"]{width:100%;padding:10px 12px;border-radius:8px;border:1px solid var(--card-border);background:rgba(15,23,42,0.6);color:var(--text-main);font-family:inherit;font-size:13px}textarea{min-height:80px;resize:vertical}textarea:focus,input:focus{outline:none;border-color:var(--keys-accent)}input.invalid{border-color:#f87171!important;background:rgba(248,113,113,0.1)!important}input.valid{border-color:#4ade80!important}.validation-msg{font-size:10px;margin-top:4px}.validation-msg.error{color:#f87171}.validation-msg.success{color:#4ade80}
    .card-spacer{flex:1}.submit-row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-top:14px}.fee-display{font-size:12px;color:var(--text-soft)}.fee-amount{color:var(--keys-accent);font-weight:600}.btn-submit{padding:10px 24px;border-radius:999px;border:1px solid var(--keys-accent-soft);background:linear-gradient(90deg,rgba(245,200,66,0.55),rgba(212,160,18,0.55));color:#061018;font-size:13px;font-weight:700;cursor:pointer}.btn-submit:hover:not([disabled]){background:linear-gradient(90deg,var(--keys-accent),var(--keys-accent-soft))}.btn-submit[disabled]{opacity:0.5;cursor:not-allowed}
    .status-msg{padding:10px 14px;border-radius:8px;font-size:12px;margin-top:10px}.status-msg.error{background:rgba(249,115,115,0.1);border:1px solid rgba(249,115,115,0.3);color:var(--danger)}.status-msg.success{background:rgba(102,214,154,0.1);border:1px solid rgba(102,214,154,0.3);color:var(--accent)}.status-msg.pending{background:rgba(245,200,66,0.1);border:1px solid rgba(245,200,66,0.3);color:var(--keys-accent)}
    .connect-prompt{text-align:center;padding:60px 20px}.connect-prompt p{color:var(--text-soft);margin-bottom:20px}.btn-connect{padding:12px 28px;border-radius:999px;border:1px solid var(--keys-accent);background:transparent;color:var(--keys-accent);font-size:14px;cursor:pointer}.btn-connect:hover{background:rgba(245,200,66,0.1)}.back-link{display:inline-flex;align-items:center;gap:6px;color:var(--text-soft);font-size:13px;margin-bottom:20px}.back-link:hover{color:var(--keys-accent)}
    .reply-section{display:none;margin-bottom:12px;padding:10px 12px;background:rgba(15,23,42,0.4);border:1px solid var(--card-border);border-radius:8px}.reply-section.active{display:block}
    .attest-signal-item{padding:10px 12px;border-bottom:1px solid rgba(255,255,255,0.05);cursor:pointer}.attest-signal-item:hover{background:rgba(251,191,36,0.1)}.attest-signal-item.selected{background:rgba(251,191,36,0.2);border-left:3px solid var(--keys-accent)}.attest-signal-item .signal-top{display:flex;align-items:center;gap:8px;margin-bottom:4px;flex-wrap:wrap}.attest-signal-item .signal-key{font-weight:600;color:var(--keys-accent);font-size:12px}.attest-signal-item .signal-content{font-size:11px;color:var(--text-soft);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .intent-tag{padding:2px 6px;border-radius:4px;font-size:10px;font-weight:600}.intent-tag.oc{background:rgba(74,222,128,0.2);color:#4ade80}.intent-tag.oi{background:rgba(248,113,113,0.2);color:#f87171}.intent-tag.ok{background:rgba(251,191,36,0.2);color:#fbbf24}.intent-tag.os{background:rgba(96,165,250,0.2);color:#60a5fa}.intent-filters{display:flex;align-items:center;gap:4px}.intent-checkbox{display:flex;align-items:center;cursor:pointer;opacity:0.5}.intent-checkbox:has(input:checked){opacity:1}.intent-checkbox input{display:none}.filter-select{padding:6px 10px;border-radius:6px;border:1px solid var(--card-border);background:rgba(15,23,42,0.6);color:var(--text-main);font-size:12px;cursor:pointer}
    .pure-signal-section{margin-top:20px}.pure-toggle-btn{width:100%;display:flex;justify-content:space-between;align-items:center;padding:14px 18px;background:var(--card-bg);border:1px solid var(--card-border);border-radius:12px;color:var(--text-main);font-size:13px;font-weight:600;text-transform:uppercase;letter-spacing:0.1em;cursor:pointer}.pure-toggle-btn:hover{border-color:var(--keys-accent)}.pure-signal-collapsed{max-height:0;overflow:hidden;transition:max-height 0.3s ease-out}.pure-signal-collapsed.expanded{max-height:400px}.pure-inner{padding:18px;background:var(--card-bg);border:1px solid var(--card-border);border-top:none;border-radius:0 0 12px 12px}
    .modal-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:1000;justify-content:center;align-items:center;padding:20px}.modal-overlay.active{display:flex}.modal{background:var(--card-bg);border:1px solid var(--card-border);border-radius:16px;width:100%;max-width:600px;max-height:80vh;display:flex;flex-direction:column;overflow:hidden}.modal-header{padding:16px 20px;border-bottom:1px solid var(--card-border);display:flex;justify-content:space-between;align-items:center}.modal-title{font-size:16px;font-weight:600;color:var(--keys-accent)}.modal-close{background:none;border:none;color:var(--text-soft);font-size:24px;cursor:pointer}.modal-filters{padding:12px 20px;border-bottom:1px solid var(--card-border);display:flex;flex-wrap:wrap;gap:10px;align-items:center}.filter-group{display:flex;align-items:center;gap:6px}.filter-label{font-size:11px;color:var(--text-soft)}.filter-input{width:70px;padding:6px 8px;border-radius:6px;border:1px solid var(--card-border);background:rgba(15,23,42,0.6);color:var(--text-main);font-size:12px}.filter-btn{padding:6px 12px;border-radius:6px;border:1px solid var(--card-border);background:transparent;color:var(--text-soft);font-size:11px;cursor:pointer}.filter-btn:hover{border-color:var(--keys-accent);color:var(--keys-accent)}.modal-body{flex:1;overflow-y:auto;padding:12px 20px}.signals-list{display:flex;flex-direction:column;gap:10px}.signal-card{background:rgba(15,23,42,0.4);border:1px solid var(--card-border);border-radius:10px;padding:12px 14px;cursor:pointer}.signal-card:hover{border-color:var(--keys-accent)}.signal-card.selected{border-color:var(--keys-accent);background:rgba(245,200,66,0.1)}.signal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}.signal-meta{display:flex;align-items:center;gap:8px;font-size:12px}.signal-key{font-weight:600;color:var(--keys-accent)}.signal-epoch{color:var(--text-soft);font-size:11px}.signal-time{color:var(--text-soft);font-size:11px}.signal-content{font-size:13px;color:var(--text-main);line-height:1.4;margin-bottom:8px;word-break:break-word}.signal-hash{font-family:monospace;font-size:10px;color:var(--text-soft);opacity:0.7}.load-more-btn{width:100%;padding:10px;margin-top:10px;border-radius:8px;border:1px dashed var(--card-border);background:transparent;color:var(--text-soft);font-size:12px;cursor:pointer}.no-signals,.loading-signals{text-align:center;padding:40px 20px;color:var(--text-soft)}.modal-footer{padding:12px 20px;border-top:1px solid var(--card-border);display:flex;justify-content:space-between;align-items:center}.btn-select-signal{padding:8px 20px;border-radius:999px;border:1px solid var(--keys-accent);background:rgba(245,200,66,0.2);color:var(--keys-accent);font-size:12px;font-weight:600;cursor:pointer}.btn-select-signal[disabled]{opacity:0.5;cursor:not-allowed}

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    /* TOOLTIP SYSTEM (matching artefacts.html style) */
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .has-tooltip{position:relative;cursor:help}
    .has-tooltip .tooltip{position:absolute;bottom:calc(100% + 8px);left:50%;transform:translateX(-50%);background:rgba(5,8,18,0.97);border:1px solid var(--accent);border-radius:10px;padding:10px 14px;font-size:12px;color:var(--text-main);max-width:280px;min-width:180px;pointer-events:none;opacity:0;visibility:hidden;transition:opacity 0.2s ease,visibility 0.2s ease;z-index:200;line-height:1.5;box-shadow:0 8px 32px rgba(0,0,0,0.5);text-align:left;white-space:normal}
    .has-tooltip .tooltip .tt-title{font-weight:600;color:var(--accent);margin-bottom:4px;font-size:13px}
    .has-tooltip .tooltip .tt-body{color:var(--text-soft);font-size:11px}
    .has-tooltip:hover .tooltip{opacity:1;visibility:visible}
    .has-tooltip .tooltip::after{content:"";position:absolute;top:100%;left:50%;transform:translateX(-50%);border:6px solid transparent;border-top-color:var(--accent)}
    .tooltip-left{left:0;transform:translateX(0)}.tooltip-left::after{left:20px}
    .tooltip-right{left:auto;right:0;transform:translateX(0)}.tooltip-right::after{left:auto;right:20px}

    /* Stealth tooltip uses blue border */
    .has-tooltip.stealth-tip .tooltip{border-color:var(--stealth-color)}
    .has-tooltip.stealth-tip .tooltip .tt-title{color:var(--stealth-color)}
    .has-tooltip.stealth-tip .tooltip::after{border-top-color:var(--stealth-color)}

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    /* HEADER STEALTH TOGGLE (compact, in-header style) */
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .card-header-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;gap:12px;flex-wrap:wrap}
    .card-header-left{display:flex;align-items:center;gap:12px}
    .card-header-right{display:flex;align-items:center;gap:12px}

    .stealth-header-toggle{display:flex;align-items:center;gap:8px;padding:6px 12px;background:rgba(102,214,154,0.1);border:1px solid rgba(102,214,154,0.4);border-radius:20px;cursor:pointer;transition:all 0.2s;user-select:none}
    .stealth-header-toggle:hover{border-color:var(--accent);background:rgba(102,214,154,0.2)}
    .stealth-header-toggle.active{background:rgba(96,165,250,0.2);border-color:var(--stealth-color)}
    .stealth-header-toggle.active .stealth-label{color:var(--stealth-color)}
    .stealth-header-toggle.active .stealth-icon{opacity:0.6}
    .stealth-header-toggle.disabled{opacity:0.4;cursor:not-allowed;background:rgba(255,255,255,0.03);border-color:rgba(255,255,255,0.1)}
    .stealth-header-toggle .stealth-icon{font-size:14px;transition:opacity 0.2s}
    .stealth-header-toggle .stealth-label{font-size:11px;color:var(--accent);font-weight:600;text-transform:uppercase;letter-spacing:0.05em}

    /* SUCCESS TOAST */
    .toast{position:fixed;top:20px;right:20px;padding:14px 20px;background:rgba(102,214,154,0.95);color:#000;border-radius:10px;font-size:14px;font-weight:600;z-index:10000;opacity:0;transform:translateY(-20px);transition:all 0.3s ease;pointer-events:none}
    .toast.show{opacity:1;transform:translateY(0)}
  </style>
</head>
<body>
<div class="toast" id="toast"></div>

<header>
  <div class="nav-inner">
    <a href="/index.html" class="logo-link"><div class="logo-dot">Î©</div><div class="logo-text">Z1N Protocol</div></a>
    <nav class="nav-links">
      <a href="/about.html">About</a>
      <a href="/live-stats.html">Live Stats</a>
      <a href="/mint-key.html">Mint Key</a>
      <a href="/your-keys.html" id="navYourKeys">Your Keys</a>
      <a href="/signals.html" class="active">Signals</a>
    </nav>
  </div>
</header>

<main class="page">
  <a href="/your-keys.html" class="back-link" id="backLink">â† Back to Your Keys</a>
  <h1>Signals</h1>
  <p class="subtitle">Participate in the Field's collective intelligence through Proof of Glyph signals.</p>

  <div id="connectState" class="connect-prompt">
    <p>Connect your wallet to send signals</p>
    <button class="btn-connect" id="btnConnect">Connect Wallet</button>
  </div>

  <div id="mainContent" style="display:none;">
    <div class="key-header-card">
      <div class="key-info">
        <span class="key-id" id="keyIdDisplay">Key #â€”</span>
        <span class="key-glyphs has-tooltip" id="keyGlyphs">â€”
          <span class="tooltip tooltip-left">
            <span class="tt-title">Glyph Sequence</span>
            <span class="tt-body">Your permanent soul signature â€” assigned at mint from your Key's unique hash.</span>
          </span>
        </span>
      </div>
      <div class="key-stats">
        <div class="stat-group">
          <span class="stat-label">Wallet:</span>
          <span id="activeWalletDisplay" style="font-family:monospace;font-size:11px;color:var(--keys-accent);">â€”</span>
        </div>
        <div class="stat-group has-tooltip">
          <span class="stat-label">Signals:</span>
          <div class="stat-dots" id="signalDots"><span class="dot-indicator open"></span><span class="dot-indicator open"></span></div>
          <span class="tooltip"><span class="tt-title">Signal Slots</span><span class="tt-body">2 per epoch. Green = used.</span></span>
        </div>
        <div class="stat-group has-tooltip">
          <span class="stat-label">Attests:</span>
          <div class="stat-dots" id="attestDots"><span class="dot-indicator open"></span><span class="dot-indicator open"></span></div>
          <span class="tooltip"><span class="tt-title">Attest Slots</span><span class="tt-body">2 per epoch.</span></span>
        </div>
        <button onclick="refreshPageData()" style="padding:6px 10px;border-radius:6px;border:1px solid var(--card-border);background:transparent;color:var(--text-soft);font-size:11px;cursor:pointer;">â†»</button>
      </div>
    </div>

    <div class="signals-layout">
      <!-- PoG SIGNAL CARD -->
      <div class="card">
        <div class="card-header-row">
          <div class="card-header-left">
            <div class="card-title has-tooltip" style="margin-bottom:0;">PoG Signal
              <span class="tooltip tooltip-left"><span class="tt-title">PoG Signal</span><span class="tt-body">Proof of Glyph signal with intent.</span></span>
            </div>
            <!-- STEALTH TOGGLE - PHILOSOPHICAL FRAMING -->
            <div class="stealth-header-toggle has-tooltip stealth-tip" id="pogStealthToggle" onclick="togglePogStealth()">
              <span class="stealth-icon" id="pogStealthIcon">ğŸ‘</span>
              <span class="stealth-label" id="pogStealthLabel">Visible</span>
              <span class="tooltip tooltip-left">
                <span class="tt-title">Signal Visibility</span>
                <span class="tt-body">When visible, the Field sees both your signal and your Key. In stealth mode, the Field receives your signal but cannot perceive its origin â€” you become invisible to the collective.</span>
              </span>
            </div>
          </div>
          <div class="card-header-right">
            <span id="pogEpochTimer" style="font-size:11px;color:var(--keys-accent);font-family:monospace;">â± --:--</span>
            <span id="pogEpochDisplay" style="font-size:11px;color:var(--text-soft);">Epoch â€”</span>
          </div>
        </div>

        <div class="toggle-grid">
          <button class="toggle-btn active" data-type="new" onclick="setSignalType('new')">New Signal</button>
          <button class="toggle-btn" data-type="reply" onclick="setSignalType('reply')">Reply To</button>
        </div>

        <div class="reply-section" id="replySection">
          <div style="font-size:11px;color:var(--text-soft);margin-bottom:6px;">Signal to reply to:</div>
          <div style="display:flex;gap:8px;">
            <input type="text" id="replyToHash" placeholder="0x... signal hash" autocomplete="off" style="flex:1;font-family:monospace;font-size:11px;">
            <button onclick="openReplyModal()" style="padding:8px 14px;border-radius:6px;border:1px solid var(--keys-accent);background:transparent;color:var(--keys-accent);font-size:12px;cursor:pointer;">Browse</button>
          </div>
        </div>

        <div class="input-label">Intent</div>
        <div class="intent-grid">
          <div class="intent-btn selected has-tooltip" data-intent="0" onclick="selectIntent(0)"><div class="intent-symbol">Î©C</div><div class="intent-name">Collective</div><span class="tooltip tooltip-left"><span class="tt-title">Î©C</span><span class="tt-body">Collective signal.</span></span></div>
          <div class="intent-btn has-tooltip" data-intent="1" onclick="selectIntent(1)"><div class="intent-symbol">Î©I</div><div class="intent-name">Individual</div><span class="tooltip"><span class="tt-title">Î©I</span><span class="tt-body">Individual signal.</span></span></div>
          <div class="intent-btn has-tooltip" data-intent="2" onclick="selectIntent(2)"><div class="intent-symbol">Î©K</div><div class="intent-name">Co-Create</div><span class="tooltip"><span class="tt-title">Î©K</span><span class="tt-body">Co-create signal.</span></span></div>
          <div class="intent-btn has-tooltip" data-intent="3" onclick="selectIntent(3)"><div class="intent-symbol">Î©S</div><div class="intent-name">Silence</div><span class="tooltip tooltip-right"><span class="tt-title">Î©S</span><span class="tt-body">Deliberate silence.</span></span></div>
        </div>

        <div class="input-group" id="signalContentCard">
          <div class="input-label"><span>Signal Content</span><span class="char-count" id="charCount">0 / 280</span></div>
          <textarea id="signalContent" placeholder="Your signal to the Field..." maxlength="280" oninput="updateCharCount()"></textarea>
        </div>

        <div class="card-spacer"></div>
        <div class="submit-row">
          <button class="btn-submit" id="btnSubmitPog" onclick="submitPoGSignal()">Submit Signal</button>
        </div>
        <div id="pogStatus"></div>
      </div>

      <!-- ATTEST CARD -->
      <div class="card" id="attestCard">
        <div class="card-header-row">
          <div class="card-header-left">
            <div class="card-title has-tooltip" style="margin-bottom:0;">Attest Signals
              <span class="tooltip tooltip-left"><span class="tt-title">Attestation</span><span class="tt-body">Attest signals from previous epoch.</span></span>
            </div>
            <!-- STEALTH TOGGLE - PHILOSOPHICAL FRAMING -->
            <div class="stealth-header-toggle has-tooltip stealth-tip" id="attestStealthToggle" onclick="toggleAttestStealth()">
              <span class="stealth-icon" id="attestStealthIcon">ğŸ‘</span>
              <span class="stealth-label" id="attestStealthLabel">Visible</span>
              <span class="tooltip tooltip-left">
                <span class="tt-title">Attestation Visibility</span>
                <span class="tt-body">When visible, your attestation strengthens both the signal and your presence in the Field. In stealth mode, you witness silently â€” your support is felt but your identity remains unseen.</span>
              </span>
            </div>
          </div>
          <div class="card-header-right">
            <span id="epochCountdown" style="font-size:11px;color:var(--keys-accent);font-family:monospace;">â± --:--</span>
            <span id="attestEpochBadge" style="font-size:11px;color:var(--text-soft);">Epoch â€”</span>
          </div>
        </div>

        <div style="margin-bottom:10px;font-size:9px;color:var(--text-soft);display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
          <span><b style="color:var(--keys-accent);">K#</b> = Key ID</span>
          <span><b>E</b> = Epoch</span>
          <span><b style="color:#fbbf24;">âœ“</b> = Attestations</span>
          <button onclick="downloadAttestCSV(event)" style="margin-left:auto;padding:3px 8px;border-radius:4px;border:1px solid var(--card-border);background:transparent;color:var(--text-soft);font-size:9px;cursor:pointer;">â¬‡ CSV</button>
        </div>

        <div style="margin-bottom:12px;display:flex;gap:8px;">
          <input type="text" id="attestSearchHash" placeholder="Search by hash or Key ID" autocomplete="off" style="flex:1;padding:8px 10px;border-radius:6px;font-size:11px;" oninput="filterAttestSignals()">
          <button onclick="loadAttestableSignals()" style="padding:8px 12px;border-radius:6px;border:1px solid var(--keys-accent);background:transparent;color:var(--keys-accent);font-size:11px;cursor:pointer;">â†»</button>
        </div>

        <div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:12px;align-items:center;">
          <select class="filter-select" id="attestSortSelect" onchange="loadAttestableSignals()" style="font-size:11px;">
            <option value="recent">Recent</option>
            <option value="attested">Most Attested</option>
          </select>
          <div class="intent-filters">
            <label class="intent-checkbox"><input type="checkbox" id="attestIntentC" checked onchange="loadAttestableSignals()"><span class="intent-tag oc" style="font-size:9px;">Î©C</span></label>
            <label class="intent-checkbox"><input type="checkbox" id="attestIntentI" checked onchange="loadAttestableSignals()"><span class="intent-tag oi" style="font-size:9px;">Î©I</span></label>
            <label class="intent-checkbox"><input type="checkbox" id="attestIntentK" checked onchange="loadAttestableSignals()"><span class="intent-tag ok" style="font-size:9px;">Î©K</span></label>
            <label class="intent-checkbox"><input type="checkbox" id="attestIntentS" checked onchange="loadAttestableSignals()"><span class="intent-tag os" style="font-size:9px;">Î©S</span></label>
          </div>
          <label style="display:flex;align-items:center;gap:4px;font-size:10px;color:var(--text-soft);margin-left:auto;cursor:pointer;">
            <input type="checkbox" id="attestHideOwn" checked onchange="loadAttestableSignals()" style="width:12px;height:12px;">Hide mine
          </label>
        </div>

        <div id="attestSignalsContainer" style="max-height:220px;overflow-y:auto;border-radius:8px;background:rgba(0,0,0,0.2);">
          <div id="attestLoadingInline" style="padding:40px 20px;text-align:center;color:var(--text-soft);font-size:12px;">Loading...</div>
          <div id="attestSignalsListInline"></div>
        </div>

        <div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--card-border);">
          <div id="attestSelectedInfoInline" style="font-size:11px;color:var(--text-soft);margin-bottom:10px;">Select a signal to attest (2 per epoch)</div>
          <button class="btn-submit" id="btnAttestNormalInline" onclick="submitAttestInline()" disabled style="width:100%;font-size:12px;padding:10px 16px;">
            âœ“ Attest Signal
          </button>
        </div>
      </div>
    </div>

    <!-- PURE SIGNAL SECTION -->
    <div class="pure-signal-section">
      <button class="pure-toggle-btn" onclick="togglePureSection()">
        <span style="display:flex;align-items:center;gap:12px;">
          <span>Pure Signal (Whisper)</span>
          <span class="stealth-header-toggle disabled has-tooltip stealth-tip" style="pointer-events:auto;" onclick="event.stopPropagation();">
            <span class="stealth-icon">ğŸ‘</span>
            <span class="stealth-label" style="color:var(--text-soft);">Always Visible</span>
            <span class="tooltip tooltip-left">
              <span class="tt-title">Whispers Cannot Hide</span>
              <span class="tt-body">Pure Signals are direct transmissions between Keys. Like a spoken word in an empty room, they carry no weight in the Field's consensus â€” but they cannot be made invisible. The intimacy of direct connection requires presence.</span>
            </span>
          </span>
        </span>
        <span id="pureToggleIcon">â–¼</span>
      </button>

      <div id="pureSignalContent" class="pure-signal-collapsed">
        <div class="pure-inner">
          <p style="font-size:12px;color:var(--text-soft);margin-bottom:14px;">Unlimited whispers. Direct transmission between Keys.</p>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
            <div class="input-group" style="margin-bottom:0;">
              <div class="input-label">Recipient Key ID (0 = broadcast)</div>
              <input type="text" id="pureRecipient" value="0" autocomplete="off" oninput="validateRecipientKey()">
              <div id="recipientValidation" class="validation-msg"></div>
            </div>

            <div class="input-group" style="margin-bottom:0;">
              <div class="input-label"><span>Message</span><span class="char-count" id="pureCharCount">0 / 500</span></div>
              <textarea id="pureContent" placeholder="Your whisper..." maxlength="500" oninput="updatePureCharCount()"></textarea>
            </div>
          </div>

          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:14px;">
            <button class="btn-submit" id="btnSubmitPure" onclick="submitPureSignal()">Send Whisper</button>
          </div>
          <div id="pureStatus"></div>
        </div>
      </div>
    </div>
  </div>
</main>

<!-- REPLY MODAL -->
<div class="modal-overlay" id="replyModal">
  <div class="modal">
    <div class="modal-header">
      <span class="modal-title">Browse Signals <span id="currentEpochBadge" style="font-size:12px;font-weight:normal;color:var(--text-soft);">(Epoch â€”)</span></span>
      <button class="modal-close" onclick="closeReplyModal()">&times;</button>
    </div>

    <div class="modal-filters">
      <div class="filter-group"><span class="filter-label">Key:</span><input type="text" class="filter-input" id="filterKeyId" placeholder="All" autocomplete="off" oninput="debouncedFilter()"></div>
      <div class="filter-group">
        <span class="filter-label">Epoch:</span>
        <input type="text" class="filter-input" id="filterEpochFrom" placeholder="From" style="width:55px;" autocomplete="off" oninput="debouncedFilter()">
        <span>â€“</span>
        <input type="text" class="filter-input" id="filterEpochTo" placeholder="To" style="width:55px;" autocomplete="off" oninput="debouncedFilter()">
      </div>
      <div class="filter-group">
        <span class="filter-label">Sort:</span>
        <select class="filter-select" id="filterSort" onchange="immediateFilter()">
          <option value="recent">Recent</option>
          <option value="attested">Attested</option>
        </select>
      </div>
      <div class="filter-group intent-filters">
        <label class="intent-checkbox"><input type="checkbox" id="filterIntentC" checked onchange="immediateFilter()"><span class="intent-tag oc">Î©C</span></label>
        <label class="intent-checkbox"><input type="checkbox" id="filterIntentI" checked onchange="immediateFilter()"><span class="intent-tag oi">Î©I</span></label>
        <label class="intent-checkbox"><input type="checkbox" id="filterIntentK" checked onchange="immediateFilter()"><span class="intent-tag ok">Î©K</span></label>
        <label class="intent-checkbox"><input type="checkbox" id="filterIntentS" checked onchange="immediateFilter()"><span class="intent-tag os">Î©S</span></label>
      </div>
      <button class="filter-btn" onclick="resetFilters()">â†º Clear</button>
    </div>

    <div style="padding:8px 20px;border-bottom:1px solid var(--card-border);font-size:10px;color:var(--text-soft);display:flex;gap:16px;flex-wrap:wrap;align-items:center;">
      <span><b style="color:var(--keys-accent);">K#</b> = Key ID</span>
      <span><b>E</b> = Epoch</span>
      <span><b style="color:#fbbf24;">âœ“</b> = Attestations</span>
      <button onclick="downloadSignalsCSV(event)" style="margin-left:auto;padding:4px 10px;border-radius:4px;border:1px solid var(--card-border);background:transparent;color:var(--text-soft);font-size:10px;cursor:pointer;">â¬‡ CSV</button>
    </div>

    <div class="modal-body">
      <div class="loading-signals" id="signalsLoading">Loading...</div>
      <div class="no-signals" id="noSignals" style="display:none;">No signals found.</div>
      <div class="signals-list" id="signalsList"></div>
      <button class="load-more-btn" id="loadMoreBtn" onclick="loadMoreSignals()" style="display:none;">Load More...</button>
    </div>

    <div class="modal-footer">
      <span id="signalCountInfo" style="font-size:11px;color:var(--text-soft);">â€“ signals</span>
      <button class="btn-select-signal" id="btnConfirmSelect" onclick="confirmSignalSelection()" disabled>Select Signal</button>
    </div>
  </div>
</div>

<script>
(function(){
  'use strict';

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TOAST NOTIFICATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function showToast(message, duration) {
    var toast = document.getElementById('toast');
    if (!toast) return;
    toast.textContent = message;
    toast.classList.add('show');
    setTimeout(function() { toast.classList.remove('show'); }, duration || 3000);
  }

  function getUrlParams() {
    var params = new URLSearchParams(window.location.search);
    return { key: params.get('key'), wallet: params.get('wallet') };
  }

  var urlParams = getUrlParams();
  var urlKeyId = null;
  var urlWallet = null;

  if (urlParams.key !== null && urlParams.key !== '') urlKeyId = parseInt(urlParams.key, 10);
  if (urlParams.wallet) urlWallet = urlParams.wallet.toLowerCase().trim();

  if (urlKeyId === null || urlWallet === null) {
    try {
      var stored = JSON.parse(localStorage.getItem('z1n_signal_context') || '{}');
      var age = Date.now() - (stored.timestamp || 0);
      if (age < 30000) {
        if (urlKeyId === null && stored.keyId !== undefined) urlKeyId = stored.keyId;
        if (urlWallet === null && stored.wallet) urlWallet = stored.wallet.toLowerCase().trim();
      }
      localStorage.removeItem('z1n_signal_context');
    } catch (e) {}
  }

  // CONFIG
  var CHAIN_ID = '0x89';
  var Z1N_KEY = '0xe27C2De6e8F1090EEAe18E1Ce3f51F1D2FeAf469';
  var Z1N_CORE = '0x4Ef6f1a53B7aE03F8eDEAB3EcD069692D1548e13';
  var Z1N_SIGNAL = '0x3CD0DF7b0aC8fdF4dB1c65149741dB12F144e3bd';

 var RPC_URLS = ['https://polygon-mainnet.g.alchemy.com/v2/P7YcT2oy0Mfad2Pedbe3y'];
  var currentRpcIndex = 0;

  var EXPLORER = 'https://polygonscan.com';
  var API_BASE = 'https://z1n-backend-production.up.railway.app/api';

  var SUBMISSION_FEE = '0';
  var SILENCE_FEE = '0';
  var ATTEST_FEE = '0';

  var SEL = {
    balanceOf: '0x70a08231',
    tokenOfOwnerByIndex: '0x2f745c59',
    ownerOf: '0x6352211e',
    glyphs: '0x887296c3',
    currentEpoch: '0x76671808',
    signalCount: '0xfd68f0e5',
    attestCount: '0xfe6569d7'
  };

  var GLYPHS = ['âˆ','Ï€','â‹®','âŠ•','âŠ—','âˆ´','âˆµ','â†”','â†»','â–³','â—‡','â—‹','â—','â–¡','â˜°','â˜·','âš‘','âœ±','âŠ¥','â‰¡','â—Š'];

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STEALTH MODE STATE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  var pogStealthEnabled = false;
  var attestStealthEnabled = false;
  var stealthRelayerAvailable = false;

  // Check if stealth relayer is available on load
  async function checkStealthAvailability() {
    try {
      var r = await fetch(API_BASE + '/relay/health', { cache: 'no-store' });
      var d = await r.json();
      stealthRelayerAvailable = d.status === 'ready';
      console.log('Stealth relayer:', stealthRelayerAvailable ? 'âœ… Ready' : 'âŒ Not available');
      
      // Update UI if not available
      if (!stealthRelayerAvailable) {
        var pt = document.getElementById('pogStealthToggle');
        var at = document.getElementById('attestStealthToggle');
        if (pt) { pt.classList.add('disabled'); pt.onclick = null; }
        if (at) { at.classList.add('disabled'); at.onclick = null; }
        var ps = document.getElementById('pogStealthStatus');
        var as = document.getElementById('attestStealthStatus');
        if (ps) ps.textContent = 'n/a';
        if (as) as.textContent = 'n/a';
      }
    } catch (e) {
      stealthRelayerAvailable = false;
      console.log('Stealth relayer: âŒ Not available');
    }
  }
  checkStealthAvailability();

 window.togglePogStealth = function() {
    if (!stealthRelayerAvailable) {
      showToast('âš ï¸ Stealth relayer not available', 3000);
      return;
    }
    pogStealthEnabled = !pogStealthEnabled;
    var toggle = document.getElementById('pogStealthToggle');
    var icon = document.getElementById('pogStealthIcon');
    var label = document.getElementById('pogStealthLabel');
    var submitBtn = document.getElementById('btnSubmitPog');
    
    toggle.classList.toggle('active', pogStealthEnabled);
    
    if (pogStealthEnabled) {
      icon.textContent = 'ğŸ‘â€ğŸ—¨';
      icon.style.opacity = '0.5';
      label.textContent = 'Hidden';
      label.style.color = 'var(--stealth-color)';
      submitBtn.textContent = 'ğŸ‘â€ğŸ—¨ Submit Hidden';
    } else {
      icon.textContent = 'ğŸ‘';
      icon.style.opacity = '1';
      label.textContent = 'Visible';
      label.style.color = 'var(--accent)';
      submitBtn.textContent = 'Submit Signal';
    }
  };

  window.toggleAttestStealth = function() {
    if (!stealthRelayerAvailable) {
      showToast('âš ï¸ Stealth relayer not available', 3000);
      return;
    }
    attestStealthEnabled = !attestStealthEnabled;
    var toggle = document.getElementById('attestStealthToggle');
    var icon = document.getElementById('attestStealthIcon');
    var label = document.getElementById('attestStealthLabel');
    
    toggle.classList.toggle('active', attestStealthEnabled);
    
    if (attestStealthEnabled) {
      icon.textContent = 'ğŸ‘â€ğŸ—¨';
      icon.style.opacity = '0.5';
      label.textContent = 'Hidden';
      label.style.color = 'var(--stealth-color)';
    } else {
      icon.textContent = 'ğŸ‘';
      icon.style.opacity = '1';
      label.textContent = 'Visible';
      label.style.color = 'var(--accent)';
    }
    
    // Update button immediately
    updateAttestBtn();
  };

  // EIP-712 signing helper
  async function signTypedData(domain, types, primaryType, message) {
    // Build the typed data structure for eth_signTypedData_v4
    var typedData = {
      types: {
        EIP712Domain: [
          { name: 'name', type: 'string' },
          { name: 'version', type: 'string' },
          { name: 'chainId', type: 'uint256' },
          { name: 'verifyingContract', type: 'address' }
        ],
        ...types
      },
      primaryType: primaryType,
      domain: domain,
      message: message
    };
    
    var signature = await provider.request({
      method: 'eth_signTypedData_v4',
      params: [currentAccount, JSON.stringify(typedData)]
    });
    
    return signature;
  }

  // Submit stealth signal via relay backend
  async function submitStealthSignal(keyId, signalHash, intent, symbolIndex, epochRef, replyTo) {
    // 1. Get signing data from relay backend
    var prepareUrl = API_BASE + '/relay/signal/prepare/' + keyId + '?' + new URLSearchParams({
      signalHash: signalHash,
      intent: String(intent),
      symbolIndex: String(symbolIndex || 0),
      epochRef: String(epochRef || 0),
      replyTo: replyTo || '0x0000000000000000000000000000000000000000000000000000000000000000'
    });
    
    var prepareRes = await fetch(prepareUrl);
    if (!prepareRes.ok) {
      var err = await prepareRes.json();
      throw new Error(err.error || 'Failed to prepare stealth signal');
    }
    var prepareData = await prepareRes.json();
    
    // 2. Sign with user's wallet
    var signature = await signTypedData(
      prepareData.domain,
      prepareData.types,
      prepareData.primaryType,
      prepareData.message
    );
    
    // 3. Submit to relay backend
    var submitRes = await fetch(API_BASE + '/relay/signal/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        signature: signature,
        keyId: keyId,
        signalHash: prepareData.message.signalHash,
        intent: prepareData.message.intent,
        symbolIndex: prepareData.message.symbolIndex,
        epochRef: prepareData.message.epochRef,
        replyTo: prepareData.message.replyTo,
        deadline: prepareData.message.deadline
      })
    });
    
    var result = await submitRes.json();
    if (!result.success) {
      throw new Error(result.error || 'Relay submission failed');
    }
    
    return result;
  }

  // Submit stealth attestation via relay backend
  async function submitStealthAttestation(keyId, signalHash) {
    // 1. Get signing data
    var prepareUrl = API_BASE + '/relay/attest/prepare/' + keyId + '?signalHash=' + encodeURIComponent(signalHash);
    
    var prepareRes = await fetch(prepareUrl);
    if (!prepareRes.ok) {
      var err = await prepareRes.json();
      throw new Error(err.error || 'Failed to prepare stealth attestation');
    }
    var prepareData = await prepareRes.json();
    
    // 2. Sign with user's wallet
    var signature = await signTypedData(
      prepareData.domain,
      prepareData.types,
      prepareData.primaryType,
      prepareData.message
    );
    
    // 3. Submit to relay backend
    var submitRes = await fetch(API_BASE + '/relay/attest/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        signature: signature,
        keyId: keyId,
        signalHash: prepareData.message.signalHash,
        deadline: prepareData.message.deadline
      })
    });
    
    var result = await submitRes.json();
    if (!result.success) {
      throw new Error(result.error || 'Relay submission failed');
    }
    
    return result;
  }

  var provider = null;
  var currentAccount = null;
  var currentKeyId = null;
  var currentEpoch = 0;
  var selectedIntent = 0;
  var signalType = 'new';
  var signalsUsed = 0;
  var attestsUsed = 0;
  var ethersLib = null;
  var selectedAttestSignal = null;
  var allAttestableSignals = [];
  var recipientValidated = true;
  var validationTimer = null;
  var keyGlyphsCache = {};

  function enc256(v) { return BigInt(v).toString(16).padStart(64, '0'); }
  function encAddr(a) { return a.slice(2).toLowerCase().padStart(64, '0'); }

  function getProvider() {
    if (window.ethereum?.providers?.length) {
      var mm = window.ethereum.providers.find(function(p){ return p.isMetaMask && !p.isBraveWallet; });
      if (mm) return mm;
      var cb = window.ethereum.providers.find(function(p){ return p.isCoinbaseWallet; });
      if (cb) return cb;
      return window.ethereum.providers[0];
    }
    if (window.ethereum) return window.ethereum;
    if (window.phantom?.ethereum) return window.phantom.ethereum;
    return null;
  }

  async function rpc(method, params) {
    var lastError = null;
    for (var i = 0; i < RPC_URLS.length; i++) {
      var rpcUrl = RPC_URLS[(currentRpcIndex + i) % RPC_URLS.length];
      try {
        var response = await fetch(rpcUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: method, params: params })
        });
        var data = await response.json();
        if (data.error) {
          if (data.error.message && (data.error.message.includes('rate') || data.error.message.includes('Too Many'))) {
            currentRpcIndex = (currentRpcIndex + 1) % RPC_URLS.length;
            continue;
          }
          throw new Error(data.error.message);
        }
        return data.result;
      } catch (err) {
        lastError = err;
        currentRpcIndex = (currentRpcIndex + 1) % RPC_URLS.length;
      }
    }
    throw lastError || new Error('All RPCs failed');
  }

  function decGlyphs(len, pack) {
    if (len === 0 || pack === BigInt(0)) return null;
    var s = [];
    for (var i = 0; i < len; i++) {
      var idx = Number((pack >> BigInt(5 * (7 - 1 - i))) & BigInt(0x1F));
      if (idx < GLYPHS.length) s.push(GLYPHS[idx]);
    }
    return s.join('Â·');
  }

  async function loadEthers() {
    if (ethersLib) return ethersLib;
    return new Promise(function(res, rej) {
      var s = document.createElement('script');
      s.src = 'https://cdnjs.cloudflare.com/ajax/libs/ethers/6.9.0/ethers.umd.min.js';
      s.onload = function() { ethersLib = window.ethers; res(ethersLib); };
      s.onerror = rej;
      document.head.appendChild(s);
    });
  }
  loadEthers().catch(function(){});

  window.selectIntent = function(i) {
    selectedIntent = i;
    document.querySelectorAll('.intent-btn').forEach(function(b) {
      b.classList.toggle('selected', parseInt(b.dataset.intent) === i);
    });

    var cc = document.getElementById('signalContentCard');
    if (cc) cc.style.display = i === 3 ? 'none' : 'block';

  };

  window.setSignalType = function(t) {
    signalType = t;
    document.querySelectorAll('.toggle-btn').forEach(function(b) {
      b.classList.toggle('active', b.dataset.type === t);
    });
    document.getElementById('replySection').classList.toggle('active', t === 'reply');
  };

  window.updateCharCount = function() {
    document.getElementById('charCount').textContent = document.getElementById('signalContent').value.length + ' / 280';
  };

  window.updatePureCharCount = function() {
    document.getElementById('pureCharCount').textContent = document.getElementById('pureContent').value.length + ' / 500';
  };

  function updateDots() {
    var sd = document.getElementById('signalDots');
    var ad = document.getElementById('attestDots');
    sd.innerHTML = (signalsUsed >= 1 ? '<span class="dot-indicator filled"></span>' : '<span class="dot-indicator open"></span>') +
                   (signalsUsed >= 2 ? '<span class="dot-indicator filled"></span>' : '<span class="dot-indicator open"></span>');
    ad.innerHTML = (attestsUsed >= 1 ? '<span class="dot-indicator filled"></span>' : '<span class="dot-indicator open"></span>') +
                   (attestsUsed >= 2 ? '<span class="dot-indicator filled"></span>' : '<span class="dot-indicator open"></span>');
  }

  window.togglePureSection = function() {
    var c = document.getElementById('pureSignalContent');
    var i = document.getElementById('pureToggleIcon');
    c.classList.toggle('expanded');
    i.textContent = c.classList.contains('expanded') ? 'â–²' : 'â–¼';
  };

  window.validateRecipientKey = function() {
    clearTimeout(validationTimer);
    var input = document.getElementById('pureRecipient');
    var msg = document.getElementById('recipientValidation');
    var keyId = parseInt(input.value) || 0;
    input.classList.remove('invalid', 'valid');
    msg.textContent = '';
    msg.className = 'validation-msg';

    if (keyId === 0) {
      recipientValidated = true;
      input.classList.add('valid');
      msg.textContent = 'âœ“ Broadcast to all';
      msg.classList.add('success');
      return;
    }

    validationTimer = setTimeout(async function() {
      msg.textContent = 'Checking...';
      try {
        var data = SEL.ownerOf + enc256(keyId);
        var result = await rpc('eth_call', [{ to: Z1N_KEY, data: data }, 'latest']);
        if (!result || result === '0x' || result.slice(26) === '0'.repeat(40)) {
          input.classList.add('invalid');
          msg.textContent = 'âœ— Key #' + keyId + ' does not exist';
          msg.className = 'validation-msg error';
          recipientValidated = false;
        } else {
          input.classList.add('valid');
          msg.textContent = 'âœ“ Key #' + keyId + ' exists';
          msg.className = 'validation-msg success';
          recipientValidated = true;
        }
      } catch (err) {
        input.classList.add('invalid');
        msg.textContent = 'âœ— Key #' + keyId + ' does not exist';
        msg.className = 'validation-msg error';
        recipientValidated = false;
      }
    }, 300);
  };

  setInterval(function() {
    var now = Math.floor(Date.now() / 1000);
    var rem = 1800 - (now % 1800);
    var m = Math.floor(rem / 60);
    var s = rem % 60;
    var d = 'â± ' + m + ':' + String(s).padStart(2, '0');
    var pt = document.getElementById('pogEpochTimer');
    var at = document.getElementById('epochCountdown');
    if (pt) pt.textContent = d;
    if (at) at.textContent = d;
  }, 1000);

  async function loadKeyData(keyId) {
    currentKeyId = keyId;

    try {
      var od = SEL.ownerOf + enc256(keyId);
      var or = await rpc('eth_call', [{ to: Z1N_KEY, data: od }, 'latest']);
      var ko = '0x' + or.slice(26).toLowerCase();

      if (ko !== currentAccount.toLowerCase()) {
        document.getElementById('keyIdDisplay').textContent = 'Key #' + keyId;
        document.getElementById('keyGlyphs').innerHTML = '<span style="color:#f87171;">âš ï¸ Key owned by different wallet</span>';
        document.getElementById('btnSubmitPog').disabled = true;
        document.getElementById('btnSubmitPure').disabled = true;
        return;
      }

      document.getElementById('btnSubmitPog').disabled = false;
      document.getElementById('btnSubmitPure').disabled = false;

      var gd = SEL.glyphs + enc256(keyId);
      var gr = await rpc('eth_call', [{ to: Z1N_KEY, data: gd }, 'latest']);
      var len = parseInt(gr.slice(2, 66), 16);
      var pack = BigInt('0x' + gr.slice(66, 130));
      var gs = decGlyphs(len, pack);

      document.getElementById('keyIdDisplay').textContent = 'Key #' + keyId;
      document.getElementById('keyGlyphs').textContent = gs || 'â€”';

      var er = await rpc('eth_call', [{ to: Z1N_CORE, data: SEL.currentEpoch }, 'latest']);
      currentEpoch = parseInt(er, 16);
      document.getElementById('pogEpochDisplay').textContent = 'Epoch ' + currentEpoch;

      var attestableEpoch = currentEpoch > 0 ? currentEpoch - 1 : 0;
      document.getElementById('attestEpochBadge').textContent = 'Epoch ' + attestableEpoch;

      var scd = SEL.signalCount + enc256(keyId) + enc256(currentEpoch);
      var scr = await rpc('eth_call', [{ to: Z1N_SIGNAL, data: scd }, 'latest']);
      signalsUsed = parseInt(scr, 16);

      var acd = SEL.attestCount + enc256(keyId) + enc256(currentEpoch);
      var acr = await rpc('eth_call', [{ to: Z1N_SIGNAL, data: acd }, 'latest']);
      attestsUsed = parseInt(acr, 16);

      updateDots();
      await loadAttestableSignals();
      updateAttestBtn();
    } catch (e) {
      console.error('loadKeyData error:', e);
    }
  }

  async function fetchKeyGlyphs(keyIds) {
    var missing = keyIds.filter(function(id) { return !keyGlyphsCache[id]; });
    if (missing.length === 0) return;

    try {
      var r = await fetch(API_BASE + '/keys', {cache: 'no-store'});
      var d = await r.json();
      if (d.keys) {
        d.keys.forEach(function(k) {
          keyGlyphsCache[k.tokenId] = k.glyphLine || '';
        });
      }
    } catch (e) {}
  }

  function getShortGlyphs(keyId) {
    var full = keyGlyphsCache[keyId] || '';
    if (!full) return '';
    return full.split(' Â· ').slice(0, 7).join('Â·');
  }

  function escapeHtml(t) { var d = document.createElement('div'); d.textContent = t; return d.innerHTML; }

  async function loadAttestableSignals() {
    var list = document.getElementById('attestSignalsListInline');
    var load = document.getElementById('attestLoadingInline');
    var info = document.getElementById('attestSelectedInfoInline');
    var badge = document.getElementById('attestEpochBadge');
    if (!list) return;

    selectedAttestSignal = null;
    list.innerHTML = '';
    if (load) load.style.display = 'block';

    try {
      var attestableEpoch = currentEpoch > 0 ? currentEpoch - 1 : 0;
      if (badge) badge.textContent = 'Epoch ' + attestableEpoch;

      var p = new URLSearchParams();
      p.set('limit', '100');
      p.set('minEpoch', String(attestableEpoch));
      p.set('maxEpoch', String(attestableEpoch));

      var sort = document.getElementById('attestSortSelect');
      if (sort) p.set('sort', sort.value);

      var ints = [];
      if (document.getElementById('attestIntentC')?.checked) ints.push('0');
      if (document.getElementById('attestIntentI')?.checked) ints.push('1');
      if (document.getElementById('attestIntentK')?.checked) ints.push('2');
      if (document.getElementById('attestIntentS')?.checked) ints.push('3');

      if (ints.length === 0) {
        if (load) load.style.display = 'none';
        list.innerHTML = '<div style="padding:30px;text-align:center;color:var(--text-soft);font-size:11px;">No intents selected.</div>';
        return;
      }
      if (ints.length < 4) p.set('intents', ints.join(','));

      var apiUrl = API_BASE + '/signals?' + p.toString();
      var r = await fetch(apiUrl, {cache: 'no-store', headers: {'Cache-Control': 'no-cache'}});
      var d = await r.json();

      if (load) load.style.display = 'none';

      var sigs = d.signals || [];
      var hide = document.getElementById('attestHideOwn')?.checked;
      if (hide && currentKeyId !== null) sigs = sigs.filter(function(s){ return s.keyId !== currentKeyId; });

      allAttestableSignals = sigs;

      await fetchKeyGlyphs(sigs.map(function(s){ return s.keyId; }));

      var search = (document.getElementById('attestSearchHash')?.value || '').trim().toLowerCase();
      if (search) {
        sigs = sigs.filter(function(s){
          return (s.hash || '').toLowerCase().includes(search) || String(s.keyId) === search;
        });
      }

      renderAttest(sigs, list, info, attestableEpoch);
      updateAttestBtn();
    } catch (e) {
      if (load) load.style.display = 'none';
      list.innerHTML = '<div style="padding:20px;text-align:center;color:#f87171;font-size:11px;">Error loading signals.<br><span style="font-size:10px;color:var(--text-soft);">Indexer may still be processing. Click â†» to retry.</span></div>';
    }
  }
  window.loadAttestableSignals = loadAttestableSignals;

  function renderAttest(sigs, list, info, ae) {
    list.innerHTML = '';
    if (sigs.length === 0) {
      list.innerHTML = '<div style="padding:30px;text-align:center;color:var(--text-soft);font-size:11px;">No signals for Epoch ' + ae + '</div>';
      if (info) info.textContent = 'No signals to attest (Epoch ' + ae + ')';
      return;
    }
    if (info) info.textContent = sigs.length + ' signals to attest (Epoch ' + ae + ')';

    sigs.forEach(function(sig) {
      var it = document.createElement('div');
      it.className = 'attest-signal-item';
      it.onclick = function() {
        document.querySelectorAll('#attestSignalsListInline .attest-signal-item.selected').forEach(function(el){ el.classList.remove('selected'); });
        it.classList.add('selected');
        selectedAttestSignal = sig;
        document.getElementById('attestSelectedInfoInline').innerHTML = 'Selected: <strong style="color:var(--keys-accent);">K#' + sig.keyId + '</strong>';
        updateAttestBtn();
      };

      var ic = ['oc', 'oi', 'ok', 'os'][sig.intent] || 'oc';
      var isym = sig.intentSymbol || ['Î©C', 'Î©I', 'Î©K', 'Î©S'][sig.intent] || '?';
      var shortGlyphs = getShortGlyphs(sig.keyId);
      var glyphSpan = shortGlyphs ? '<span style="font-size:10px;color:var(--text-soft);margin-left:4px;">' + shortGlyphs + '</span>' : '';

      it.innerHTML =
        '<div class="signal-top">' +
          '<span class="signal-key">K#' + sig.keyId + '</span>' + glyphSpan +
          '<span class="intent-tag ' + ic + '" style="font-size:9px;">' + isym + '</span>' +
          '<span style="color:#fbbf24;font-size:10px;">âœ“' + (sig.attestCount || 0) + '</span>' +
          '<span style="font-size:9px;color:var(--text-soft);">' + (sig.timeAgo || '') + '</span>' +
        '</div>' +
        '<div class="signal-content">' + escapeHtml(sig.cid || '[Silence]') + '</div>';

      list.appendChild(it);
    });
  }

  window.filterAttestSignals = function() {
    var search = (document.getElementById('attestSearchHash')?.value || '').trim().toLowerCase();
    var list = document.getElementById('attestSignalsListInline');
    var info = document.getElementById('attestSelectedInfoInline');
    var ae = currentEpoch > 0 ? currentEpoch - 1 : 0;

    if (!search) { renderAttest(allAttestableSignals, list, info, ae); return; }
    var f = allAttestableSignals.filter(function(s) {
      return (s.hash || '').toLowerCase().includes(search) || String(s.keyId) === search;
    });
    renderAttest(f, list, info, ae);
  };

  function updateAttestBtn() {
    var btn = document.getElementById('btnAttestNormalInline');
    var can = !!selectedAttestSignal && attestsUsed < 2;

    if (!btn) return;

    btn.disabled = !can;
    
   var prefix = attestStealthEnabled ? 'ğŸ‘â€ğŸ—¨ ' : 'âœ“ ';
    
    if (attestsUsed >= 2) {
      btn.textContent = prefix + 'Max Attests (2/2)';
      return;
    }
    if (!selectedAttestSignal) {
      btn.textContent = prefix + 'Attest Signal';
      return;
    }
    btn.textContent = prefix + 'Attest K#' + selectedAttestSignal.keyId;
  }

  window.submitAttestInline = async function() {
    if (!selectedAttestSignal || currentKeyId === null) { alert('Select a signal'); return; }
    if (attestsUsed >= 2) { alert('Max 2 attestations per epoch'); return; }

    var btn = document.getElementById('btnAttestNormalInline');
    var orig = btn.textContent;
    btn.disabled = true; btn.textContent = 'â³...';

    try {
      var hash = selectedAttestSignal.hash;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEALTH MODE: Use relay backend
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (attestStealthEnabled && stealthRelayerAvailable) {
        btn.textContent = 'ğŸ”’ Sign message...';
        
        try {
          var result = await submitStealthAttestation(currentKeyId, hash);
          
          attestsUsed++;
          updateDots();
          await loadAttestableSignals();
          updateAttestBtn();
          showToast('ğŸ”’ Stealth attestation submitted!', 4000);
          btn.textContent = 'ğŸ”’ âœ…';
          return;
        } catch (e) {
          alert('Stealth failed: ' + (e.message || 'Unknown error'));
          btn.textContent = orig; btn.disabled = false;
          return;
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // NORMAL MODE: Direct contract call with fee
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      await loadEthers();
      var iface = new ethersLib.Interface(['function attestSignal(bytes32 signalHash)']);
      var data = iface.encodeFunctionData('attestSignal', [hash]);

      var txParams = { from: currentAccount, to: Z1N_SIGNAL, data: data };

      var tx = await provider.request({method:'eth_sendTransaction',params:[txParams]});
      btn.textContent = 'â³ Confirming...';

      for (var i = 0; i < 30; i++) {
        await new Promise(function(r){ setTimeout(r, 2000); });
        var rc = await rpc('eth_getTransactionReceipt', [tx]);
        if (rc && rc.status === '0x1') {
          attestsUsed++;
          updateDots();
          await loadAttestableSignals();
          updateAttestBtn();
          showToast('âœ… Attestation submitted!', 4000);
          btn.textContent = 'âœ…';
          return;
        }
        if (rc && rc.status === '0x0') throw new Error('Transaction reverted on-chain');
      }
      throw new Error('Timeout waiting for receipt');
    } catch (e) {
      var msg = e.message || 'Failed';
      alert('Failed: ' + msg);
      btn.textContent = orig; btn.disabled = false;
    }
  };

  window.submitPoGSignal = async function() {
    var st = document.getElementById('pogStatus');
    var ct = document.getElementById('signalContent').value.trim();
    if (selectedIntent !== 3 && !ct) { st.innerHTML = '<div class="status-msg error">Enter content.</div>'; return; }
    if (signalsUsed >= 2) { st.innerHTML = '<div class="status-msg error">Max 2 signals this epoch.</div>'; return; }

    st.innerHTML = '<div class="status-msg pending">Preparing...</div>';

    try {
      await loadEthers();
      var tid = currentKeyId;

      var hash = '0x' + (Date.now().toString(16) + Math.random().toString(16).slice(2)).padEnd(64, '0').slice(0, 64);
      var cid = selectedIntent === 3 ? '' : ct.slice(0, 250);
      var sym = 0, intent = selectedIntent, stype = selectedIntent === 3 ? 3 : 2, eref = 0;

      var reply = '0x' + '0'.repeat(64);
      if (signalType === 'reply') {
        var ri = document.getElementById('replyToHash').value.trim();
        if (ri && ri.startsWith('0x') && ri.length >= 66) { reply = ri.slice(0, 66); stype = 1; eref = currentEpoch > 0 ? currentEpoch - 1 : 0; }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEALTH MODE: Use relay backend
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (pogStealthEnabled && stealthRelayerAvailable) {
        st.innerHTML = '<div class="status-msg pending">ğŸ”’ Stealth mode: Sign message...</div>';
        
        try {
          var result = await submitStealthSignal(tid, hash, intent, sym, eref, reply);
          
          signalsUsed++;
          updateDots();
          document.getElementById('signalContent').value = '';
          window.updateCharCount();
          st.innerHTML = '<div class="status-msg success">ğŸ”’ Stealth signal submitted! <a href="' + EXPLORER + '/tx/' + result.txHash + '" target="_blank">View tx</a></div>';
          showToast('ğŸ”’ Stealth signal submitted!', 4000);
          return;
        } catch (e) {
          st.innerHTML = '<div class="status-msg error">Stealth failed: ' + (e.message || 'Unknown error').slice(0, 150) + '</div>';
          return;
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // NORMAL MODE: Direct contract call with fee
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     var iface = new ethersLib.Interface(['function submitSignal(uint256 tokenId, bytes32 signalHash, string cid, uint8 symbolIndex, uint8 intent, uint8 signalType, uint16 epochRef, bytes32 replyTo)']);
      var data = iface.encodeFunctionData('submitSignal', [tid, hash, cid, sym, intent, stype, eref, reply]);

      st.innerHTML = '<div class="status-msg pending">Confirm in wallet...</div>';

      var txParams = { from: currentAccount, to: Z1N_SIGNAL, data: data };

      var tx = await provider.request({method:'eth_sendTransaction',params:[txParams]});
      st.innerHTML = '<div class="status-msg pending">Sent...</div>';

      for (var i = 0; i < 60; i++) {
        await new Promise(function(r){ setTimeout(r, 2000); });
        var rc = await rpc('eth_getTransactionReceipt', [tx]);
        if (rc && rc.status === '0x1') {
          signalsUsed++;
          updateDots();
          document.getElementById('signalContent').value = '';
          window.updateCharCount();
          st.innerHTML = '<div class="status-msg success">âœ… Submitted! <a href="' + EXPLORER + '/tx/' + tx + '" target="_blank">View tx</a></div>';
          showToast('âœ… Signal submitted!', 4000);
          return;
        }
        if (rc && rc.status === '0x0') { st.innerHTML = '<div class="status-msg error">Tx reverted on-chain. Check contract.</div>'; return; }
      }
      st.innerHTML = '<div class="status-msg error">Timeout waiting for receipt.</div>';
    } catch (e) {
      var msg = e.message || 'Failed';
      st.innerHTML = '<div class="status-msg error">' + msg.slice(0, 200) + '</div>';
    }
  };

  window.submitPureSignal = async function() {
    var st = document.getElementById('pureStatus');
    var ct = document.getElementById('pureContent').value.trim();
    var to = parseInt(document.getElementById('pureRecipient').value) || 0;

    if (!currentAccount) { st.innerHTML = '<div class="status-msg error">Wallet not connected.</div>'; return; }
    if (currentKeyId === null) { st.innerHTML = '<div class="status-msg error">No Key.</div>'; return; }
    if (!ct) { st.innerHTML = '<div class="status-msg error">Enter message.</div>'; return; }
    if (to !== 0 && !recipientValidated) { st.innerHTML = '<div class="status-msg error">Invalid recipient Key ID.</div>'; return; }

    st.innerHTML = '<div class="status-msg pending">Sending whisper...</div>';

    try {
      await loadEthers();
      var iface = new ethersLib.Interface(['function sendPure(uint256 fromKeyId, uint256 toKeyId, string cid)']);
      var data = iface.encodeFunctionData('sendPure', [currentKeyId, to, ct]);

      st.innerHTML = '<div class="status-msg pending">Confirm (no fee)...</div>';
      var tx = await provider.request({method:'eth_sendTransaction',params:[{from:currentAccount,to:Z1N_SIGNAL,data:data}]});
      st.innerHTML = '<div class="status-msg pending">Sent...</div>';

      for (var i = 0; i < 30; i++) {
        await new Promise(function(r){ setTimeout(r, 2000); });
        var rc = await rpc('eth_getTransactionReceipt', [tx]);
        if (rc && rc.status === '0x1') {
          document.getElementById('pureContent').value = '';
          document.getElementById('pureCharCount').textContent = '0 / 500';
          st.innerHTML = '<div class="status-msg success">âœ“ Delivered! <a href="' + EXPLORER + '/tx/' + tx + '" target="_blank">View tx</a></div>';
          showToast('âœ… Whisper delivered!', 4000);
          return;
        }
        if (rc && rc.status === '0x0') { st.innerHTML = '<div class="status-msg error">Tx failed.</div>'; return; }
      }
      st.innerHTML = '<div class="status-msg error">Timeout waiting for receipt.</div>';
    } catch (e) {
      st.innerHTML = '<div class="status-msg error">' + (e.message || 'Failed').slice(0, 200) + '</div>';
    }
  };

  window.refreshPageData = async function() {
    try {
      var er = await rpc('eth_call', [{ to: Z1N_CORE, data: SEL.currentEpoch }, 'latest']);
      currentEpoch = parseInt(er, 16);
      document.getElementById('pogEpochDisplay').textContent = 'Epoch ' + currentEpoch;

      if (currentKeyId !== null) {
        var scd = SEL.signalCount + enc256(currentKeyId) + enc256(currentEpoch);
        var scr = await rpc('eth_call', [{ to: Z1N_SIGNAL, data: scd }, 'latest']);
        signalsUsed = parseInt(scr, 16);

        var acd = SEL.attestCount + enc256(currentKeyId) + enc256(currentEpoch);
        var acr = await rpc('eth_call', [{ to: Z1N_SIGNAL, data: acd }, 'latest']);
        attestsUsed = parseInt(acr, 16);

        updateDots();
      }

      await loadAttestableSignals();
    } catch (e) {}
  };

  var modalOff = 0, modalLim = 20, selSig = null, filterTimer = null;

  window.debouncedFilter = function() { clearTimeout(filterTimer); filterTimer = setTimeout(applyFilters, 300); };
  window.immediateFilter = function() { clearTimeout(filterTimer); applyFilters(); };
  window.openReplyModal = function() { document.getElementById('replyModal').classList.add('active'); loadModal(); };
  window.closeReplyModal = function() { document.getElementById('replyModal').classList.remove('active'); };
  window.resetFilters = function() {
    document.getElementById('filterKeyId').value = '';
    document.getElementById('filterEpochFrom').value = '';
    document.getElementById('filterEpochTo').value = '';
    document.getElementById('filterSort').value = 'recent';
    document.getElementById('filterIntentC').checked = true;
    document.getElementById('filterIntentI').checked = true;
    document.getElementById('filterIntentK').checked = true;
    document.getElementById('filterIntentS').checked = true;
    modalOff = 0; selSig = null;
    loadModal();
  };
  window.applyFilters = function() { modalOff = 0; selSig = null; loadModal(); };

  async function loadModal(append) {
    var list = document.getElementById('signalsList');
    var load = document.getElementById('signalsLoading');
    var no = document.getElementById('noSignals');
    var more = document.getElementById('loadMoreBtn');
    var cnt = document.getElementById('signalCountInfo');

    if (!append) { list.innerHTML = ''; load.style.display = 'block'; no.style.display = 'none'; more.style.display = 'none'; }

    try {
      var p = new URLSearchParams();
      p.set('limit', String(modalLim));
      p.set('offset', String(modalOff));

      var ki = document.getElementById('filterKeyId').value.trim(); if (ki) p.set('keyId', ki);
      var ef = document.getElementById('filterEpochFrom').value.trim();
      var et = document.getElementById('filterEpochTo').value.trim();
      if (ef) p.set('minEpoch', ef);
      if (et) p.set('maxEpoch', et);

      p.set('sort', document.getElementById('filterSort').value);

      var ints = [];
      if (document.getElementById('filterIntentC').checked) ints.push('0');
      if (document.getElementById('filterIntentI').checked) ints.push('1');
      if (document.getElementById('filterIntentK').checked) ints.push('2');
      if (document.getElementById('filterIntentS').checked) ints.push('3');
      if (ints.length === 0) { load.style.display = 'none'; no.textContent = 'No intents selected.'; no.style.display = 'block'; return; }
      if (ints.length < 4) p.set('intents', ints.join(','));

      var r = await fetch(API_BASE + '/signals?' + p.toString(), {cache: 'no-store', headers: {'Cache-Control': 'no-cache'}});
      var d = await r.json();

      load.style.display = 'none';

      var eb = document.getElementById('currentEpochBadge');
      if (eb && d.currentEpoch) eb.textContent = '(Epoch ' + d.currentEpoch + ')';
      if (cnt) cnt.textContent = (d.total || 0) + ' signals';

      if ((d.signals || []).length === 0 && !append) { no.textContent = 'No signals found.'; no.style.display = 'block'; return; }

      await fetchKeyGlyphs((d.signals || []).map(function(s){ return s.keyId; }));

      (d.signals || []).forEach(function(sig) {
        var c = document.createElement('div');
        c.className = 'signal-card';
        c.dataset.hash = sig.hash;

        var ic = (sig.intentSymbol || '').toLowerCase().replace('Ï‰', 'o');
        var ct = sig.cid || '[Silence]';
        var shortGlyphs = getShortGlyphs(sig.keyId);
        var glyphSpan = shortGlyphs ? '<span style="font-size:11px;color:var(--text-soft);margin-left:4px;">' + shortGlyphs + '</span>' : '';

        c.innerHTML =
          '<div class="signal-header">' +
            '<div class="signal-meta">' +
              '<span class="signal-key">K#' + sig.keyId + '</span>' + glyphSpan +
              '<span class="intent-tag ' + ic + '">' + (sig.intentSymbol || '') + '</span>' +
              '<span class="signal-epoch">E' + sig.epoch + '</span>' +
              '<span style="color:#fbbf24;">âœ“' + (sig.attestCount || 0) + '</span>' +
            '</div>' +
            '<span class="signal-time">' + (sig.timeAgo || '') + '</span>' +
          '</div>' +
          '<div class="signal-content">' + escapeHtml(ct) + '</div>' +
          '<div class="signal-hash">' + sig.hash.slice(0, 18) + '...</div>';

        c.onclick = function() {
          document.querySelectorAll('.signal-card.selected').forEach(function(el){ el.classList.remove('selected'); });
          c.classList.add('selected');
          selSig = sig;
          document.getElementById('btnConfirmSelect').disabled = false;
        };

        list.appendChild(c);
      });

      more.style.display = d.hasMore ? 'block' : 'none';
    } catch (e) {
      load.style.display = 'none';
      no.textContent = 'Error: ' + e.message;
      no.style.display = 'block';
    }
  }

  window.loadMoreSignals = function() { modalOff += modalLim; loadModal(true); };
  window.confirmSignalSelection = function() { if (!selSig) return; document.getElementById('replyToHash').value = selSig.hash; closeReplyModal(); };
  document.addEventListener('click', function(e) { if (e.target.classList.contains('modal-overlay')) closeReplyModal(); });
  document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeReplyModal(); });

  // CSV helpers
  function escapeCSV(val) {
    if (val === null || val === undefined) return '';
    var s = String(val);
    if (s.includes(',') || s.includes('"') || s.includes('\n')) return '"' + s.replace(/"/g, '""') + '"';
    return s;
  }

  function downloadCSV(rows, filename) {
    var csv = rows.map(function(row){ return row.map(escapeCSV).join(','); }).join('\n');
    var blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  window.downloadSignalsCSV = async function(evt) {
    evt = evt || window.event;
    var btn = evt && evt.target ? evt.target : null;

    try {
      if (btn) { btn.textContent = 'â³...'; btn.disabled = true; }

      var p = new URLSearchParams();
      p.set('limit', '10000');
      var ki = document.getElementById('filterKeyId').value.trim(); if (ki) p.set('keyId', ki);
      var ef = document.getElementById('filterEpochFrom').value.trim();
      var et = document.getElementById('filterEpochTo').value.trim();
      if (ef) p.set('minEpoch', ef);
      if (et) p.set('maxEpoch', et);
      p.set('sort', document.getElementById('filterSort').value);

      var ints = [];
      if (document.getElementById('filterIntentC').checked) ints.push('0');
      if (document.getElementById('filterIntentI').checked) ints.push('1');
      if (document.getElementById('filterIntentK').checked) ints.push('2');
      if (document.getElementById('filterIntentS').checked) ints.push('3');
      if (ints.length < 4) p.set('intents', ints.join(','));

      var r = await fetch(API_BASE + '/signals?' + p.toString(), {cache: 'no-store'});
      var d = await r.json();

      await fetchKeyGlyphs((d.signals || []).map(function(s){ return s.keyId; }));

      var intentNames = ['OmegaC (Collective)', 'OmegaI (Individual)', 'OmegaK (Co-Create)', 'OmegaS (Silence)'];
      var rows = [['Hash','Key ID','Key Glyphs','Intent','Signal Content','Epoch','Attestations','Timestamp']];

      (d.signals || []).forEach(function(sig){
        rows.push([
          sig.hash,
          sig.keyId,
          keyGlyphsCache[sig.keyId] || '',
          intentNames[sig.intent] || sig.intentSymbol || '',
          sig.cid || '[Silence]',
          sig.epoch,
          sig.attestCount || 0,
          sig.timeAgo || ''
        ]);
      });

      downloadCSV(rows, 'z1n_signals_' + new Date().toISOString().slice(0,10) + '.csv');
    } catch (e) {
      alert('Error downloading CSV: ' + e.message);
    } finally {
      if (btn) { btn.textContent = 'â¬‡ CSV'; btn.disabled = false; }
    }
  };

  window.downloadAttestCSV = async function(evt) {
    evt = evt || window.event;
    var btn = evt && evt.target ? evt.target : null;

    try {
      if (btn) { btn.textContent = 'â³'; btn.disabled = true; }

      var attestableEpoch = currentEpoch > 0 ? currentEpoch - 1 : 0;

      var p = new URLSearchParams();
      p.set('limit', '10000');
      p.set('minEpoch', String(attestableEpoch));
      p.set('maxEpoch', String(attestableEpoch));

      var sort = document.getElementById('attestSortSelect');
      if (sort) p.set('sort', sort.value);

      var ints = [];
      if (document.getElementById('attestIntentC')?.checked) ints.push('0');
      if (document.getElementById('attestIntentI')?.checked) ints.push('1');
      if (document.getElementById('attestIntentK')?.checked) ints.push('2');
      if (document.getElementById('attestIntentS')?.checked) ints.push('3');
      if (ints.length < 4) p.set('intents', ints.join(','));

      var r = await fetch(API_BASE + '/signals?' + p.toString(), {cache: 'no-store'});
      var d = await r.json();

      var sigs = d.signals || [];
      var hide = document.getElementById('attestHideOwn')?.checked;
      if (hide && currentKeyId !== null) sigs = sigs.filter(function(s){ return s.keyId !== currentKeyId; });

      await fetchKeyGlyphs(sigs.map(function(s){ return s.keyId; }));

      var intentNames = ['OmegaC (Collective)', 'OmegaI (Individual)', 'OmegaK (Co-Create)', 'OmegaS (Silence)'];
      var rows = [['Hash','Key ID','Key Glyphs','Intent','Signal Content','Epoch','Attestations','Timestamp']];

      sigs.forEach(function(sig){
        rows.push([
          sig.hash,
          sig.keyId,
          keyGlyphsCache[sig.keyId] || '',
          intentNames[sig.intent] || sig.intentSymbol || '',
          sig.cid || '[Silence]',
          sig.epoch,
          sig.attestCount || 0,
          sig.timeAgo || ''
        ]);
      });

      downloadCSV(rows, 'z1n_attest_epoch' + attestableEpoch + '_' + new Date().toISOString().slice(0,10) + '.csv');
    } catch (e) {
      alert('Error downloading CSV: ' + e.message);
    } finally {
      if (btn) { btn.textContent = 'â¬‡ CSV'; btn.disabled = false; }
    }
  };

  async function connect() {
    var eth = getProvider();
    if (!eth) { alert('Install a Web3 wallet (MetaMask/Coinbase/Phantom).'); return; }

    provider = eth;

    try {
      var accs = await provider.request({ method: 'eth_accounts' });
      if (!accs || accs.length === 0) accs = await provider.request({ method: 'eth_requestAccounts' });

      var selectedAccount = null;
      if (urlWallet) {
        selectedAccount = accs.find(function(a){ return a.toLowerCase() === urlWallet; }) || accs[0];
      } else {
        selectedAccount = accs[0];
      }
      currentAccount = selectedAccount;

      var cid = await provider.request({ method: 'eth_chainId' });
      if (cid !== CHAIN_ID) {
        try {
          await provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: CHAIN_ID }] });
        } catch (se) {
          if (se.code === 4902) {
            await provider.request({
              method: 'wallet_addEthereumChain',
              params: [{
                chainId: CHAIN_ID,
                chainName: 'Polygon',
                nativeCurrency: { name: 'POL', symbol: 'POL', decimals: 18 },
                rpcUrls: ['https://polygon-rpc.com'],
                blockExplorerUrls: ['https://polygonscan.com']
              }]
            });
          }
        }
      }

      var wantedKey = urlKeyId;
      currentKeyId = null;

      if (wantedKey !== null && !isNaN(wantedKey) && wantedKey >= 0) {
        try {
          var ownerData = SEL.ownerOf + enc256(wantedKey);
          var ownerResult = await rpc('eth_call', [{ to: Z1N_KEY, data: ownerData }, 'latest']);
          var keyOwner = '0x' + ownerResult.slice(26).toLowerCase();
          if (keyOwner === currentAccount.toLowerCase()) currentKeyId = wantedKey;
        } catch (e) {}
      }

      if (currentKeyId === null) {
        var bd = SEL.balanceOf + encAddr(currentAccount);
        var br = await rpc('eth_call', [{ to: Z1N_KEY, data: bd }, 'latest']);
        var bal = parseInt(br, 16);
        if (bal === 0) { alert('No Z1N Keys on this wallet'); location.href = '/mint-key.html'; return; }

        var td = SEL.tokenOfOwnerByIndex + encAddr(currentAccount) + enc256(0);
        var tr = await rpc('eth_call', [{ to: Z1N_KEY, data: td }, 'latest']);
        currentKeyId = parseInt(tr, 16);
      }

      document.getElementById('connectState').style.display = 'none';
      document.getElementById('mainContent').style.display = 'block';
      document.getElementById('activeWalletDisplay').textContent = currentAccount.slice(0, 6) + '...' + currentAccount.slice(-4);

      var walletUrl = '/your-keys.html?wallet=' + encodeURIComponent(currentAccount);
      document.getElementById('backLink').href = walletUrl;
      document.getElementById('navYourKeys').href = walletUrl;

      try {
        localStorage.setItem('z1n_signal_context', JSON.stringify({ keyId: currentKeyId, wallet: currentAccount, timestamp: Date.now() }));
      } catch (e) {}

      await loadKeyData(currentKeyId);

      if (!provider.__z1nBound) {
        provider.__z1nBound = true;
        provider.on?.('accountsChanged', function(){ location.reload(); });
        provider.on?.('chainChanged', function(){ location.reload(); });
      }
    } catch (e) {
      alert('Failed: ' + e.message);
    }
  }

  document.getElementById('btnConnect').onclick = connect;

  var eth = getProvider();
  if (eth) {
    eth.request({ method: 'eth_accounts' }).then(function(a) {
      if (a && a.length > 0) connect();
    }).catch(function(){});
  }

})();
</script>
</body>
</html>